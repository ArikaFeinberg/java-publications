самом первом
занятии как вы помните мы говорили о том
как важно понимать то что мы
разрабатываем какой-то конечный продукт
как правильно насколько важно оценивать
свою работу планировать и и исходя из
того что главной нашей целью является не
просто кот не просто какое-то количество
классов написанная какие-то библиотек
является продукт и нам нужно учиться
строить свою работу организовать процесс
таким образом чтобы продукт получался
как можно лучше как можно быстрее и
качественней так дальше и живём мы
сейчас время конкурентная
программ очень много производителей
много но это касается всего сайтов игр
программ чего варево
поэтому и умение должны быть
соответствующие для того чтобы вот в
такой конкурентной среде разрабатываете
продукт и которые могут выжить в такой
конкуренции

а как же нам все-таки проектировать
как же создавать программы для того
чтобы они соответствовали отвечали вот
эти нашим желаниям
того что программа должна быть легко
изменяемый поддерживаемый

но это действительно 90 чем нас чем нам
интересны 90 и в разрезе наши и тем и
тем что если мы подумаем то 90 это время
очень насыщенного развития вот нашей
индустрии разработке программного
обеспечения очень насыщенный и очень
важное 10 лет если мы возьмем девяностый
год то кто помнит каком году может вы
читали вышел первый персональный
компьютер японский 84 ну то есть пример
носят что то есть 90 год это буквально 6
лет вот вы думаете что свет это не так
много на 2013 год хорошо мы еще помним
как вышел первый перестали компьютер это
только-только начало в принципе их не
так много еще они продаются но рынок не
настолько большой интернет существует
только в лабораториях в конце девяностых
у нас появился windows компьютеры
проникли в рынок вырос в 10000 там
процентов какие-то миллионы процентов
появились огромная индустрия разработки
программ для персональных компьютеров
интернет не просто появился но уже
достиг вот этого пика то что называет
пузырь доткомов до 1 интернет корпорации
которые были такими хайпом как примерно
bitcoin полтора года назад да то есть
бросились туда вкладывать они взлетели
потом мы провалились например вы как
bitcoin еще хуже потому что это были
настоящие компании которые обанкротились
до из них выжил они так много там amazon
там яху и так дальше многие так и не
смогли это пережить соответственно в
течение этих 10 лет индустрия
стремительно развивалась что приходило
очень много людей потому что требовалось
намного больше программ и примерно в это
время и стали явными
какие-то проблемы которых мы говорили с
тем что как важно разрабатывать
уметь разрабатывать продукты в команде
которая меняется на протяжении долгого
периода времени то есть в это время
первые какие-то попытки организовать
опыт да поделиться им как-то его там
сгруппировать выступить на конференции
или написать какую-то книгу они наиболее
органичные и понятны потому что это
происходит вот как раз во время развития
всей сферы если мы посмотрим какие то
известные книги касающиеся разработки
повод во времени то в принципе
большинство тех которые вы назовете вот
первого раза там какую-то генку фортом
паттерны разработки это может быть
мартин фаулер рефакторинг какие-то еще
вещи они скорее всего будут написаны в
этот промежуток то есть вот накопилось
какое-то количество знаний и они вот
вышли там год 94 год foger 98 год какие
в это время были инструменты у
разработчиков

*много вырезано, не по теме*

то есть выходит книга одного из авторов
граде путь один из авторов книги про
шаблоны проектирования которую так
обычно знают гоф dagen go for типа банда
4 которые написали эту книгу у него есть
другая книга которая касается именно
объектно-ориентированной методологии
он там описывает как строить различные
системы
ну и в принципе как не крути но большая
часть этой литературы посвящена именно
каким-то о пышным по пышным подходом
решению проблем которые возникают при
разработке на объектно-ориентированных
языках функционально языки хоть и
появились как намного раньше это одна из
первых парадигм но с особенностями
железа с особенностями времени они еще
не имели такого крупного место в
разработке пилота они сейчас не то чтобы
сильно имеют тогда и подавно да потому
что как мы знаем для того чтобы
вспоминаю прошлую лекцию чтобы
эффективно работать с этими всеми
допустим не изменяемыми структурами
нужны хорошие компиляторы нужны хорошие
сборщики мусора нужно чтобы это все было
эффективно во времена когда вы можете
прочитать какие-то книги про разработку
в 90 когда люди там компе лили файлы на
плюсах там по два часа но естественно
говорить ну это не шутка это нереально
два часа то есть там проблема например
что нам делать нас проект собирается два
часа сейчас такое тоже бывает для очень
крупных проектов но это не настолько
распространено как какие-то проблемы в
то время соответственно те инструменты
тогда еще были и скользим и так мы
начали да и проблемы которые возникали
они были преимущественного пышный
логичным таким развитием различной
литературы
книг принципов подходов и так дальше
можно считать вышедшую уже в 2000 году
то есть вот как раз вот в конце этого
десятилетия статью роберта мартина
который у нас завсегдатай наших лекций
да и вообще один из таких основных
авторов наверное в сфере вот как раз
архитектуры разработке различных там
подходов эта статья называется design
principles and design patterns
мы шли на 2000 году 2001 году появился
джон манифест одним из авторов которых
являются который выявляется тоже сам
мартин и 2002 году на основе этой статьи
во многом до появилась уже полноценная
книга
джан principles patterns and practice
которая абсолютно техническое
в том плане что сейчас мы уже снова таки
привыкли смотреть на jar как на
методологию касающиеся менеджмента то
это во-первых носит свежайшая книга
только год прошел после придумывания она
она абсолютно техническая она наполовину
посвящена разработке по
и наполовину тоже разработки но с точки
зрения организации работы команды
но все равно скажем так с колокольни
разработчикам

такая каменная статуя огромной она очень
жестко или как это сваренная структура
что такое жесткость эта проблема системы
при которой когда вам нужно внести
изменение в что-то одно вам до сложно
внести изменение что-то одно потому что
когда вы начинаете вносить изменение
сюда вам приходится еще потом поменять
здесь и потом поменять здесь
соответственно одно изменение
тащит за собой цепочку других и очень
сложно поменять какую-то вещь не
втянувшись переписывание кода там на
месяц вперед например достаточно понятны
и симптом очень часто возникают
программах его к чему почему это плохо с
точки зрения продукта потому что если мы
посмотрим на какого-то менеджера да
неважно назовем это проджект менеджер
скрам мастер как угодно то он будет
гораздо меньшим
меньшей охотой до из гораздо больше
опаской соглашаться на измене и
программу
очевидно на то есть любое изменение
кроме критического фикса будет
восприниматься как потенциальная
опасность то есть можете спрашивать
команда поправить не такие можем сколько
вам нужно там три дня три дня до 2
недели значит заладится в то что нужно
переписать это это и это это становится
естественно это вредно для продукта
когда он не может меняться быстро и это
очень такой хороший симптом когда
увидите что вот какое-то локальное
изменение все равно тащит за собой кучу
какого-то переделывания как ни странно
но этот симптом идет очень часто вместе
с казалось бы противоположным но очень
похожим 2 это враджа лети то есть
хрупкость жесткая система может быть
хрупкой одновременно это как такой
большой хрустальный кубок
да он как бы жесткий сложной от него
ручку отпилить потому что какой-то
момент он просто рассыпется да он такой
напряженный что какая-то трещина и он
рассыпается хрупкость отличается
жесткости тем чтобы под хрупкости мы
понимаем то что мы чиним в одном месте а
ломается в другом да то есть вот мы сюда
по его что поправили а там отвалилась на
мы поправили вроде бы как отображение
имени пользователя она перестала
сохраняться или отправлять на сервер
здесь поправили окошечко от атома
отвалилась какая-то там валидация еще
чего то есть какие-то изменения которые
ну вот они вроде бы как не связаны но
они абсолютно почему-то так происходит
это ситуация еще более критическая с
точки зрения например команды или
клиента
потому что клиентам может быть
пользователи наши да потому что это это
со стороны выглядит так что команда не
имеет контроля над продуктом в принципе
да то есть это люди вроде бы как
профессионалы занимаются чем-то но они
как бы не знаю к чему приведут их
действия да то есть они что-то сделают
отвалится в пяти местах это еще больше и
такой вот звоночек того что все плохо да
при этом обычно эти два симптома ходят
вместе как ни крути
третья проблема вот такая вот и mobility
да не сложность в движений прошлый раз
когда мы обсуждали о п был такой вот
была такая проблема да джангл банана
monkey суть в том что очень сложно из
проекта вытащить какую-то часть и
перенести его в другой проект я еще
тогда сказал что это не проблема у п
потому что по это просто
техника подход который очень легко
описать и мы это попытались сделать это
проблема естественной системы проблема
вашего проектирования при котором вроде
бы как все делается для того чтобы можно
было какие-то компоненты
переиспользовать например вы делаете
какие-то приложения утилиты ну допустим
которые работают сетью вы один раз
написали сеть и хотите потом перенести
это в другой проект потому что там вроде
бы как такое же самое там сетевая часть
какой-то протокол
но она оттуда как-то не выковыривает а
потому что за ним тащиться куча каких-то
зависимости приходится их все вычищать и
она потом не работает и в итоге как бы
проще сначала написать чем пытаться эту
часть оттуда вытащить это безусловно
проблема которая становится важной в в
компаниях которых больше одного продукта
который при этом достаточно смежные
потому что как ни крути получается
заметная ситуации когда сидят например
команды делать одно и то же то есть они
пишут тупо один тот же функционал два
раза это неэффективно это самое лучшее
трата времени и денег и последняя такая
ситуация про нее меньше говорят но она
действительно важно и важно не только
для пышных языков означает вискозы день
найти вязкость до
вязкость вот это вот более такая хитрая
ситуация реже про него говорят хотя она
вот очень критично
ну и как вы понимаете это касается
только у по языков это касается любой
системой программой над которой вы
работаете что такое вязкость когда вам
нужно сделать какое-то изменение
программе
очевидно что у вас есть два пути первый
путь правильный до такой светлая сторона
сделать все по дизайну то есть как бы
избавил спроектировать все нормально как
бы чтобы не сломалось и второй путь это
значит за кастрировать ставить обмотать
скотчем жвачкой соплями его значит х и
да какой путь вы выберете в среднем ну
то есть какое путь люди выбирают
ну это просто главным фактом есть
является то что быстрее и сколько у нас
есть времени очевидно то есть к нам
говорят сделать и фичу вас есть месяц вы
так я щас на нарисуем спроектируем или
там сделать вич у вас есть два дня боже
мой сейчас туда примотать то есть
зависит от того насколько это измене
сложно сделать и вот подумайте о том что
если система спроектирована так что в
ней правильную вещь сделать ну легче чем
костыль да то есть она она более
просится то ситуации когда вам захочется
этот касты вставлять будут ну очень
редки и потому что если вы можете это
сделать проще быстрее понятней чем
придумывать какую-то такую странную
ситуацию то вы скорее всего будете
пользоваться есть обратная ситуация
когда ну сделать по вашему дизайну
настолько сложно напряжена долго вот
этого самая вязка езда когда для того
чтобы все сделать правильно вы не можете
вы не можете сделать быстро например для
того чтобы добавить какую-то пищу нужно
тут добавить 5 классов там поверять 3
конфига там залить что-то на сервер там
что то сделать а тут я могу три строчки
написать и все заработает да и вот
вместо того чтобы в этом болоте очень
долго делать правильную систему вы
делаете быстрые хаки которые потом
накапливаются и все все ломается это
очень мне кажется важная характеристика
который касается любой программы да вот
я
как такое вот эвристическое правило вот
в моей программе сейчас сделать
неправильно легче чем правильно или
все-таки дизайн предрасполагает к тому
что легче будет кому-то сделать так как
я предполагал и по праведному это очень
важная штука как для архитектуры по
опыта может даже сам мартин говорит что
любой архитектор долго не должен просто
рисовать на доске а потом говорить
разработчикам там идите все делаете да
он должен сам с этим писать сам этим
пользоваться понимать насколько удобно
этим пользоваться для того чтобы быть
уверенным что людям это удобно быстро и
понятно вот такие проблемы которые как
мы понимаем выливаются в
не возможность быстро реагировать на
изменения длительную разработку то есть
они выливаются все эти ситуации которые
приводят к печальным последствиям для
продукта что же является причиной всего
этого ну очевидно те вещи про которые мы
уже говорили то есть изменения в
требованиях то есть принципе большинство
этих проблем проявляются когда у нас не
статическое tz когда у нас постоянно
меняются какие-то ситуации то есть нам
нужно что-то править менять если мы
делаем свой продукт а это вообще
естественный процесс мы постоянно и вы
должны улучшать другая ситуация которая
очень сильно влияет на появление всех
этих проблем это правильная работа с
зависимостями да то есть у вас есть
какие-то свои модули классы возить
какие-то библиотеки и вам нужно как-то
организовать их связи между собой таким
образом чтобы они не превратились такой
вас plush ной комок который потом станет
и жестким и хрупким одновременно и это
сложная задача задача такая в принципе
нетривиальное нужно думать как ее решать
но когда это не получается это очень
хорошо заметно по вот этим вот признаком
что же предлагается
держать уме для того чтобы
постараться избежать такой ситуации
собственно это и есть те самые принципы
принципы solid которые мы сейчас обсудим
solid это мнемоническое правило да то
есть просто аббревиатура буква
соответственно она не не не находится
там в порядке важности или в порядке
какой-то ну то есть это начнем мы как ни
странно самого последнего потому что она
будет хорошо перекликаться с тем что мы
говорили прошлый раз последний принцип
называется dependency engine и в
какой-то степени вы про него уже
говорили как прошлый раз когда прождали
о чем же вообще в принципе о.п.
я буду так вот такой вот пример очень
частая ситуация в любой программе когда
у нас есть какое-то действие и она
принципе логично
раскладывается на три таких вот слой чем
слой ниже тем он конкретнее чем он выше
тем он абстрактнее
есть какой-то high-level полисе да то
есть что делать
есть какой-то средний уровень типа
механизм есть какой-то utility уровень и
где мы уже делаем конкретно здесь справа
у меня пример допустим мы пишем с вами
чат какой-то там messenger
да и у нас есть наверху это
принципиальное решение что нужно делать
это отправить пользователю sticker
вон там есть наверху там executed
править стикер ну там сообщение там типа
как skype или ещё где-то на среднем
уровне мы определяем как же конкретно
этот стикер будет отправляться то есть у
нас есть какой-то
место штендер по тисе пи которые знают
что можно отправлять по тисе пи канал да
и на самом нижнем уровне там где у нас
это уже utility там где у нас уже
непосредственно маленький класс который
умеет писать байты байтов канал вот три
таких уровня достаточно понятных моем
случае вот у меня здесь как идет
верхний уровень создает класс пониже
этот создает пониже и последнее уже
выполняет действие то есть чистом виде
тоже что мы рисовали прошлый раз один
модуль зависит от 2 и зависит от 3 что
здесь не так ну в принципе
здесь не так то что мы так с таким же
успехом могли это и носи написать то
есть у нас конечно здесь есть new
который там создает объект по большому
счету мы никакого
никого правь этого пышного не используя
то есть у нас верхний уровень зависит от
нижнего да то есть если я захочу
поменять и отправлять наше сообщение не
patisserie
а почти типы например поменяем и наш
способ дали пою hype то мне придется
лезть наш верхний уровень файлы в полисе
скажем так да и менять там нужно моем
случае менять присваивание просто но
возможно придется что-то еще другое меня
то есть верхний уровень как бы зависит
от к реализации нижнего уровня это плохо
мы стараемся этого избежать и вообще об
и придумали для того чтобы от этого
избавиться в том что мы для этого делаем
мы для этого между этими вещами
вставляем прослойку абстракции да по
сути принцип andynsane вершин состоит из
двух частей первая часть как раз вот оно
это и постулирует модули верхних уровней
не должны зависеть от модулей нижних
уровней и те и другие должны зависеть от
абстракции а под абстракциями в наших
современных языках мы подразумеваем
абстрактные классы интерфейсы и
протоколы называют этой как угодно
просто это те вещи которые не зависят от
конкретной реализации что мы можем
сделать в этой ситуации но нам нужно
подменить
конкретные вещи на абстрактные его что
это у нас превращается есть а кстати
сделал еще одно изменение кто глазастый
потом скажете то есть у нас есть верхний
уровень
тот же самый про который решаешься нужно
отправить стикер и у него же есть
какой-то
интерфейс который ему он с которым он
работает не зная какой конкретно
реализация будет подставлена да то есть
по сути этот интерфейс
моем случае места штендер да он
относится к верхнему уровню
уровнем пониже у нас уже появляется
реализация этого интерфейса да какой то
механизм в нашем случае там от роли не
байтов по тисе пи и точно также
серые точно так же интерфейс для того
чтобы отвратить и на нижнем уровне нашем
случае these ты уже конкретный bright ну
и нижний уровень который тоже реализует
этот интерфейс
что здесь поменялось главная вещь
которую мы здесь достигли это то что за
счет вот такого объединения вот по сути
вот такого да вот раз здесь мы реализуем
и вот так в моем верхней вот этом цент
action хендлера уже нет никакой ссылки
найти на конкретный и 7 сочтены
нет ссылки в принципе если мы возьмем и
объединим вот этот центр action хендлер
и messages интерфейс в один пакет мы
можем их объединить принципе в отдельную
вот такую вот
бинарную сущность скажем так точно может
быть одними jorney котельная д л а л к
отдельный проект то есть у него уже нет
в принципе
ссылок вот сюда то есть что это означает
что если в прошлый раз на нашем прошлом
примере
если здесь как поменяв какие-то вещи
внутри вот этого класса него пришлось
влезть повыше и менять там тоже есть
шансом что-то сломать то здесь даже если
вот здесь вот на этом уровне вообще не
зная верная бомба взорвётся да то этот
верхний уровень пройден принципе не
знают у него на это ссылок нет а он как
бы работает только с интерфейсом который
самый предоставляет естественно что в
конкретных ситуациях
меняется ну некоторые вещи то есть здесь
нарисовано так что есть например вот наш
какой-то механизм и рядом с ним же в
этом интервью в этом же пакете скажем
лежит интерфейс с которым он работает
соответственно чтобы чтобы предоставить
этому уровню до какой-то конкретный
объект мы должны реализовать интерфейс
где-то до его туда передать
иногда получается так что этот интерфейс
пережать наоборот вниз например когда у
вас есть вот допустим есть компания и
вот тот же самый пример несколько
продуктов все работают сетью и какая то
значит команда которая работает вот на
примере нашей сети они реализовали там
какие то там тисе пи от про отправлял ки
эти типы и отправлял key you deep и
и они сделали общий интерфейс здесь же
сендер да например
и сказали вот берите все пользуйтесь до
оставляйте себе работать с этим
интерфейсом и сами решайте какой
конкретно лизации вам нужно то есть в
таком виде здесь вот этот интерфейс он
будет на уровень ниже но это не проблема
это как раз та часть абстрактности
которую может быть сложнее понять да
потому что нет конкретного шага
перенесите вот этот интерфейс этот пакет
это скорее общий подход к тому что мы
разделяем вещи так чтобы они поменьше
друг от друга знали тем самым мы
уменьшаем вероятность возникновения
вот этой самой жесткости да потому что
при таком разделении получается что если
мы меняем что-то здесь ну нам не
придётся переделывать верхний уровень
потому что они связаны между собой
только этим интерфейсом
то есть изменение могут быть только если
мы поменяем интерфейс но и хрупкость
соответственно тоже уменьшается потому
что ну риск от того что бак отсюда
попадет туда
ислама что неожиданное он тоже намного
намного меньше вот такой принцип
по большому счету это всего лишь
формулирование главные особенности опыт
того что пользуйтесь тем для чего это
придумали до пользуйтесь абстракциями
которые умеют по не принимать и
обрабатывать сообщение у этого принципа
есть второй пункт тоже важный он звучит
как
абстракции не должны зависеть от
реализации реализации должны зависеть от
абстракции что имеется ввиду это уже
касается не объединение внутри в пакеты
до какого-то какой-то конкретной вещи
интерфейс это касается того как этот
интерфейс
выделить то есть на моём примере как бы
просто взял и вот метод который мы
используем да вот например там sender
какой-то или brighter я просто его взял
и вынес в интерфейс какая можно с этим
возникнуть проблема ну вот в нашем
случае например вот здесь вот у нас есть
здесь и преврати у которого есть метод в
рай байт на массив байт он принимать
ситуация если мы захотим например
стрелять байты почти теперь каналу может
же такое быть ну хотим по запросам
отправить байты почти канал нам этих
байтов в принципе будет не совсем
достаточно нам еще нужно конкретно может
быть url знать то есть если тисе
приказал просто открывается да тут
например почти теперь уже есть какие то
какие то нюансы ответственном этот метод
хотелось бы расширить и сюда добавить
еще метод string урал
ну и байты получается что если мы
работаем с интерфейсом то в нашем
интерфейсе байтс
боец brighter метод в рай бойцы уже
пролезет какой-то странный еще одна
строка string гульда вместе с байтами а
потом мы придумаем другую реализацию
нашего райтера по какому-то другому
каналу которому нужны
там еще какие-то параметры и получается
что наша абстракция на на ней совсем
абстрактная этот url нужен только в
одном случае
да оно как бы достаточно кривая скажем
так а какой-то другой параметр
используется в третьем случае по сути
принцип говорит как раз о том что вот
нужно избегать таких ситуаций
за счет того что мы создаем абстракцию
да и конкретной реализации должны уметь
работать с ней они наоборот пытаться
запихнуть туда что-то свою
я думаю что это является таким логичным
продолжением того о чем мы говорили на
прошлом занятии и принципе вот этот вот
этот подход можно сказать он является
вторым по важности всех принципов
потому что ну это как раз по правильное
использование о п в принципе по
правильное использование того для чего
этот инструмент придумывался кто заметил
какая здесь еще есть разница между
скриншотами вот этим да вот этом коды
вот этом коде
кроме того что его не из интерфейса
замечайте
родиться в том что здесь остается
маленькая проблемка которую мы не решили
это создание конкретных объектов то
здесь у меня правило тисе пи например
bike rider
я создаю этот объект до здесь я это
убрал весь у меня просто поле ну которое
для на данном случае днепра ниц и ализе
раваны могу ли я сейчас написать сюда
равно new
и city bike rider но не могу потому что
мы же специально сделали так чтобы вы на
этом уровне ссылки не было на нижний
уровень да то есть но он красным будет
нет ничего импортировать это специально
сделано так скажем про дизайн
соответственно нам нужно придумать
какой-то способ для того чтобы и вот
туда конкретную реализацию передать для
того чтобы вот сам этот объект не
создавал и мы из этого плавно переходим
к другому принципу
другому подходу скажем так он звучит как
и на бирже нур control
это не относится к 100 лет принципам это
просто важное понятие которое звучит
очень часто сегодня там разработки по
это достаточно абстрактное понятие что
такое
какого контроля какой контроль мы
инвертируем да то есть есть такой пряди
как control flow имеется виду что вот вы
пишете программу вы пишете ее там шаг за
шагом да какие то операции выполняются и
мы как бы контролируйте выполнение этой
программы вызове этот метод создает
экземпляр среди туда пойди туда то есть
у вас есть вот у вас есть контроль за
вот этим вот ну хорошие слов лауда поток
который идет внутри этой программы в
общем под инверсии мы понимаем что
вместо того что вы задаете какие-то
конкретные последовательности кто-то
другой да например какой-то контейнер
или какое-то описание то есть ваша
задача просто писать какие-то части кода
до которая будет выполняться дергаться
кем-то в каких-то ситуациях
так написано во многих многих ну так так
это описано в википедии так об этом
говорят разных видео но в нашем случае
здесь это касается немножко более
простого подхода более простого простой
ситуации если мы возьмем вот вот этот
вот предыдущий screen где
класс создает объект data у нас есть вот
этот наш экшен hinder да ему нужен
экземпляр место штендера и он как бы сам
знает где его взять то есть он просто
берет и лезет куда то да и себе его
кладёт ну да пусть он просто знает 6
конструктор это мог быть не конструктор
это мог бы быть какой-то метод ну в
общем он сам знаете его взять на то есть
он как бы сам управляет этим сам
контролирует этот поток данной ситуации
под инверсией управление до имеется
ввиду что вместо того чтобы объект лес
за кабель зачем-то кто-то ему этот
объект предоставит мы лишим его
необходимости знать куда лезть
мы просто предала механизм который сам
ему скажет вот пользуйся этим
соответственно первым и простым и
очевидным решением вот этой проблемы
того если у нас нету ссылки на
конкретную реализацию внутри вот этого
пакета
что же сделать является что ну вот
первый пример это просто конструктор
как ни странно да то есть объект
принимает конкретно реализацию в
конструкторе
сюда мы уже можем передать любую
конкретную реализацию этот пакет
продолжает не знать про эти конкретной
реализации то есть мы реализовали вот
этот вот этот подход за счет того что мы
просто будем передавать
экземпляр конструкторе на сегодня в
программах часто используется еще более
продвинутый подход который если вы
пробовали писать там какие то там не
знаю spring любые в приложениям бисерные
вы про него слышали и скорее всего даже
пользовались механизм заключается в том
что ну через конструктор удобно но здесь
может быть какие-то там 80 параметров
которые нужно передавать например ты
какой-то обработчик там какого-то http
запроса ему нужно ссылкой на там и на
базу данных там и настой на все это
конструктор и кто этот конструктор будет
вызывать было бы неплохо просто иметь
какие-то поля внутри наших сущностей да
и обозначать их каким-то значком
обозначением каким-то там колючкой да и
это бы означало что вот я не знаю где
это взять пожалуйста дайте мне вот это
не создавай явно конструктора например
через там публичные сеттер или еще что
то соответственно для того чтобы эта
вещь работал нам нужно просто придумать
такую систему такой контейнер
который сам будет в нужный момент
подставлять сюда
конкретное действие в этом и есть
реализация вот не выражена в control а в
том плане что мы создаем объект мы не
сами заполняем а конкретные поля мы
говорим пожалуйста просто подставим сюда
какие-то значения и мы не знаем когда
они там появятся
это то что мы называем dependency
injection
почему injection потому что наш
контейнер он как будто бы таким шприцом
до оставляет сюда нужное место
конкретной зависимости мы такое видим
там на джаве
например там какой-то all the while то
есть мы говорим что нам нужен этот
сервис я не знаю где его взять и
контейнер да он нам его подставит это
может быть на любом языке потому что это
но в принципе если вы подумаете это
хорошее упражнение для программирования
как написать такой контейнер но это
несложно нужно просто взять объект
которого нужно нужно нужно создать этот
контейнер
научиться регистрировать ним зависимости
каким-то способом например сказать ему
что пожалуйста если просят интерфейс там
какой-то экшен то пожалуйста отдавая вот
эту реализацию сложить эти типы там
словарик внутри контейнера а потом когда
контейнеру нужно обработать конкретный
объект он просто берет распаковывает его
через рефлексию например да то есть
модель какие у него есть поля смотри
какие там типы из своего словарика
подставляет туда конкретной реализации
это несложно но зато это позволяет нам
вообще не беспокоиться о том а где наши
зависимости брать да то есть это
позволяет нам держать вот эту структуру
достаточно чистой до
почему потому что они публичные но они
не обязательно при зачастую они но они
не сейчас здесь посмотрим я бы не сказал
что это восстановить инкапсуляция потому
что наоборот вот 10 здесь у меня указаны
публичное поль публичное поле да и
некоторые фреймворке поддерживать только
публичное поляне которые могут родить
приватные ситуации потому что наш класс
он изначально подразумевают что эти поля
будут заполнены да что там будет
конкретно реализации интерфейса и более
того мы можем потом взять этот класс и
отлично его протестировать на счет того
что мы его возьмем мы знаем что он будет
работать когда у него будут все вот эти
зависимости предоставлены мы создадим
своей реализации этих сервисов которые
будут работать так что создавать
какой-то очень специфический граничный
случай до подставим туда вы выполнить
вызовем у него метод и посмотрим что он
ведет себя так как нам нужна и создадим
ещё
все таких тестов на всех граничные
случаи да и как бы и тем самым все будет
то есть в данном с данной ситуации это
не является внутренним полем это
наоборот как бы вещь которая но
ожидается что она будет предоставлена
извини это просто механизм другой
механизм из-за того чтобы запихать в
конструктор я буду
ссылаться на вот эти вот прикольные
картинки описание принципов которые я
нагуглил когда готовился к первой лекции
потом выйдет и что автор репозитории
автора зовут алексей я понял что ну это
явно наш человек поэтому вдвойне приятно
что человек который там они очень
прикольной репозитории там с примерами
разных структур данных и еще маленькая
статья с красивыми картинками про
принципы в чем здесь
аналогия налоги а в том что когда вы
проектируете розетку
у вас есть эта система да как оно там по
стене идиотом провода и у нее есть
скажем так интерфейс весьма физические
интерфейсы это вот плиточка с двумя
дырочками до интерфейс говорит что вот
сюда вставляете да вот так вот их будет
работать это ведь тот же самый тот же
самый вот этот вот вот этот уровень да
то есть у нас есть механизм того как у
нас подключаются провода и
предоставляется интерфейс розетка вот
остальные вещи да на картинке показано
что это могут быть там медные провода ли
сюжету что угодно они как бы уже
реализует эту вещь понимаю что они могут
могут с этим работать для этого
достаточно просто иметь
розетку нужного формата ну надеюсь что
это
не очень сложно потому что главная идея
я здесь немножко насыпал и прады и про
injection и и про прочие такие более
сложные вещи но главная идея здесь как
раз вот она обрисовывается вот этими
двумя картинками вместо того чтобы иметь
конкретная зависимости мы работаем с
абстракциями абстракции нам нужны даже
тогда когда у нас есть одна реализация
потому что но мы не можем быть уверены
что она всегда будет 1 и более того мы
можем создавать тестовые реализации для
наших нужд
да и за счет того что мы это работаем мы
сможем объединять эти уровни в разные
пакеты которые не будут ссылаться друг
на друга тем самым разрывая наш вот этот
вот жесткий клубок зависимости внутри
приложений если у нас такая система то
естественно все ссылают на верхний
уровень славится на нижний нижний на
самые нижние соответственно мы не можем
их разделить по разным пакетам они
являются чем-то единым и неразделимо
идем дальше я сказал что dependency
injection помощь насте принцип самым
важным безусловно является open клаус
именно два эти принципы по большому
счету и определяют главную идею того как
стоит разрабатывать
объектно-ориентированные системы причем
даже несколько объектно-ориентированные
объектные в принципе то есть есть языки
которые не очень и об этом типа java
скрипта но в них есть объекты то есть
там есть объекты вы то есть они просто
немножко другие там есть поля методы и
так дальше которым можно использовать но
объектами самим понятием и активно
оперируем open class принцип как раз
самый яркий пример того что самое важное
является самым абстрактным и по этому
самому не понятно то есть звучит он
очень так вроде бы как не понятно да что
система должна быть открыта к расширению
но закрыта для модика модификации если
спрашивать в среднем людей что они в
этом поводу думают а это очень часто
упирается в то что не стоит
переопределять методы
точнее стоит переопределять но не нужно
добавлять новый в родительский класс это
небольшая такая ну не скажу что каша но
не совсем понимание главной идеей
которая стать
из-за за всем принципам я приведу снова
пример от мартина не кажется достаточно
яркий и понятный кто пишет visual studio
это шар припишите на пальцах вы
пользуетесь какими-то вот например шар
поесть и шар perdo который добавляет
кучу всяких обвеса для рефакторинга и
прочих вещей пользуйтесь исключительно
внутренними средствами студии ли там не
значит каких-то сторонних вещей ну вот
если вы пишете на шарпе то есть между
visual studio сейчас уже есть rider ну
допустим если же остуди и есть такая
штука как ришар pir это такая отдельная
по сути a dong visual studio который
позволяет
ну очень круто улучшить наши процессы
работы по написанию кода
рефакторинг но тут те кто пишут на джаве
вы пишете в идее скорее всего нас
большой вероятностью вы к этим всем
пользуйтесь потому что этот
это другая ну по сути даже под тех же
разработчиков просто в виде отдельной
программы каким образом связаны между
собой visual studio или sharp очевидно
что когда разрабатывалась visual studio
и когда она пишется сейчас that includes
апдейты у них нет доступа к исходникам
ришар пера очевидно visual studio
десятки аддонов до которые там
раскрашивают нашу рабочую область
добавляют новые менюшки какие-то вещи и
ну то есть их огромное количество
соответственно если вот мы возьмем что
зелененьким это source code в dependency
да то есть по сути using да то у нас вот
такой вот стрелочки нет да то есть у нас
visual studio не знают папе sharp но при
этом
ришар пир когда пишется он естественно
пишется специально под visual studio он
знает что тип его тут у нас есть
какой-то там граф представление здесь у
нас какое то рабочее окно то есть
очевидно что ришар признает на уровне
source кода про visual studio мы ему ему
принципиально нужно чтобы с ним для
этого нормально работать а красники мы
обозначим то что называется как раз
control the control flow или control то
есть то что что вызывает какие методы
visual studio когда стартует она же ведь
сама запускается вы кликаете по экзешник
у visual studio и нужно как-то узнать
где мои donna где они как они не
попросить их проинициализирована
посмотреть получилось ли у них про
инициализироваться ну и в какой-то
момент наверное она дергает какие-то
методы которые на которые даны могут
реагировать и там что то менять например
там подсветку менять какие-то другие
вещи то есть вот этот вот эта стрелка
идет в эту сторону то есть visual studio
не зная про то что есть ришар пир и ещё
25 других аддонов она умеет с ними
работать абстрактно но умеет работать с
ними так что вот есть какие-то аддоны
вся система построена таким образом что
у вас есть какой-то marketplace и таких
аддонов может быть много и каждый из них
работать по такому принципу если один из
них от отвалится но вам покажется
кошечка какой-то дон перестал работать
извините ну все мы там перезапустим ся
вот этой части очень сложно поломать
visual studio можно конечно но типа если
хорошо написано visual studio на решая
проеме поломает он скорее скажет что у
вас ваша дон некорректность доведет
лежит туда куда ему не положено я
надеюсь это понятный пример
давайте теперь возьмем наш пример с
мессенджером что там допустим вот у нас
есть наш условный назовем его там ультра
ультра мега skype их какой-то очередной
который мы пишем там skype грамм
и например мы добавляем такую вот есть
такая фича мы добавляем возможность что
у нас вот сейчас новый год до скоро
например у нас новый год а например вот
вам менеджер говорит какие-то праздники
и вам и говорят что давайте мы хотим
чтобы у нас была возможность на новый
год людям там отправлять новый смайлик
там типа ли он елочки хотим добавить
хотим чтобы там можно было снежок
вызвать какой-то чтоб падал
подарочек какой-то но вообщем какая-то
такая вот ерунда которая будет абсолютно
временная которая вот для
лояльности пользователей ну понятно
киеве думаю понятно кейс соответственно
нас появляется какая-то такая какая-то
такая штука там допустим нью ер так и
отдельная команда значит работать над
этим мир и пока я думаю логично что если
это например большая компания и у вас
есть такой вот механизм до что если вот
сейчас где-то новый год а там где
независимости в америке китайский новый
год что есть команды которые работают
над этими расширениями и было бы очень
странно если бы основная программа имела
бы вот эти зависимости от всего то есть
вы начать заходите какой-то класс и там
значит using сразу и китайский новый год
это мы все остальные вину типа это это
очевидно плохо то есть очевидно что вот
этой стрелки в эту сторону нет на то
есть skype не должен знать про то что
есть какая-то штука которая добавляет
там еще один смолик но при этом
новогоднем
команды работающие над этим аддоном она
прекрасно знает как работает skype куда
нужно что добавить и как сделать то
здесь вот эта стрелка есть ну а как же
ботать с этими штуками ей нужно как-то
знать что у нее не просто здесь есть
например набор смайликов которые можно
отправлять или или стикеров или модель
еще чего то есть какие то какие то
провайдеры скажем так у которых нужно
спросить которых может быть разное
количество
и которые нам эти стикеры могут
предоставить и вот здесь даже специально
сделала вот такую вот вещь подразумевают
что как бы между остуди работает с
любыми аддонами не знаю что-то конкретно
решать
точно так же и наша программа она не
знает сколько там сейчас запущена
дополнений сколько там сейчас какой
сейчас временный пак запущен но она
должна знать кто нам может предоставить
нашей смайлики
да кто может дать нам эти анимашки и так
дальше видите очень похожие системы и
копнём ещё на уровень ниже допустим вот
вы теперь не просто в команде расширения
для программа вы прям в кор команде
которая продолжает писать наш ношу этот
skype грамм условной и у нас здесь
начать есть наша система и в ней есть
система от отправки отрисовки наших
сообщений ну массажистом какой-то
месседжи score и у нас есть сообщение на
текстовое самое простое очевидно что при
программа развивается и выдох хотите
добавить что-то аудиосообщение записали
звук проводила сообщение фоточки
отправлять фоточки файлы отправлять в
общем миллион вещей которые можно
отправлять получается какая интересная
вещь что нас есть наши разное сообщение
массаж то есть там аудио-видео там
допустим
и вот нас есть наша care system you
задача какая
уметь например от рисовать эти сообщения
в нашем окне датой чтобы приходит
сообщение иметь его отрисовать уметь там
как-то записать это в логе
уметь там это все сделать и логично что
эту систему
бы хорошо бы написать так чтобы вот она
была стабильна то есть мы написали и она
работает оно отрисовывает
и и не нужно постоянно дергать
поэтому очевидно что если с каждым новым
сообщением там стикером видеофайлам там
и чем остальным нам придется свозить
сюда будет плохо что мы будем ломать
но туда залезли там грязными руками
поковырялись и сломали нам бы очень
хотелось чтобы вот эта система умело
работать просто сообщением каким-то не
зная какой у нее был набор алгоритмов
она говорила что я вот знаю что есть
сообщение я ему например отправляю
команду там отрисоваться на экране да то
есть текст просто выводиться текстом
аудио нарисую такую красивую ты тут
штучку да там с этими с частотами видео
там прям ставится например фреймов вот
она умеет с ними работать но не знает
про то какие час конкретно сообщение мы
можем отправлять потому что мы их можем
миллион добавить ну а сами сообщение
соответственно естественно знают как бы
что как работает core для того чтобы они
могли нужным образом
реализовывать это все видите какая общая
система получается она очень похожи и
весил pink волос принцип он как раз и
говорит про вот этот подход про то что
что означает система должна быть открыта
к расширению на закрыта к модификации
это означает что мы создаём систему в
этом сложность создаем например
поддержку аддонов и как только мы
создали поддержку аддонов система
открыта к расширению создавайте миллиона
до насколько вы могут вас есть
конкретный механизм как они будут
работать для того чтобы добавить новый
дон вам не нужно лезть саму систему она
закрыта к тому чтобы вы туда лезли
то же самое здесь мы создали поддержку
например там временных функционалов
сезон так и назовем это как угодно
теперь мы можем их раздать эти задачи
миллиону там индусских разработчиков
сказать им чтобы они делали пакеты под
под америка день американской
независимости и вообще не бояться потому
что программа с этим работать и даже на
уровне кора когда мы пишем свою
программу например mis ojos да и вот
здесь вот core я привожу пример там на
геймдеве про то что есть играя на
работает с игроком а игрок может быть
локальный и удаленный бот там еще все
что угодно
если мы сможем сохранить вот здесь вот
такую же структуру то у нас намного
меньше шансов ошибиться если у нас здесь
будет какой-то мэсседж
и для того чтобы добавить еще один тип
сообщение например аудиосообщение нам
нужно будет просто например
переопределить месседжа у наследоваться
от него и при определить сам какие-то
нужные функции там типа как себя от
рисовать или как тебя там отправить то
изменение вносимые одним человеком вот
очень локальные и понятный он никак не
сможешь сломать вот эту всю систему до
которая работает с любым сообщением в
принципе не на понимание open class
принципа как люди тот я спрашивал там
помню студента
первом семестре что типа вот нельзя
период нужно переопределять методы
нельзя своих дописывать это почему
происходит потому что это взгляд вот
этой стороны человеку дали задание вот
тебе сердце сделает мне пожалуйста
аудиосообщение и он работает вот в этом
вот маленьком как бы окошечке да и он
знает что чтобы все работало ему нужно
переопределить нужны методы месседжи и
пока будет рисоваться но если вот сюда
залезть и что-то дописать то естественно
скорее всего она перестанет работать
потому что эти места джим работает этот
корни там он не ожидает такого поведения
но и в общем она там все сломать но это
же очень простой подход это очень
понятный типа такой junior ски в том
плане что всю работу за вас уже сделали
вся сложность том чтобы сделать вот
такой korg который работает с
абстрактным месседжем а потом уже отдать
расширение тем кто может их сделать и
принципа pink lust
как раз об этом явно и говорит наш
пример уж ты здесь картинка pro mixer
который я уже один раз показывал которую
счастье в 2 сайт он почему-то не хочет
потом отдуваться давай
собственно пример шож такое какой пример
pro mixer
а то что у нас есть наша база есть
подменяем ее венчики да мы создаем
миксер таким образом чтобы такой чтобы
мы могли их подменять создавать новые
продавать например отдельно какими-то
пока мы по 5 долларов но при этом для
того чтобы для создания нового меньше к
понадобилось просто создать новую эту
штуку но она будет подключаться все
равно через
через тот механизм который
предоставляется самой базой до нужно
просто поддерживать правильный скажем
так благ то же самое то есть любая дон
должен просто работать по нужным
механизму любой сезон парк должен
работать по механизму любое сообщение
должно просто реализовывать наши
требования любой венчик должен быть
взаимозаменяемыми если у вас есть
какой-то особый
4 5 генчик который работает а когда мы
разобрали миксер поменяли и стали то вот
ну это плохо и просто с миксером это
очень очевидно до что если вас есть
четыре который вставляется и 5 для
которого нужно все разобрать то это
очевидно ну а для программы почему-то
становится не так очевидно хотя идеи
абсолютно тоже самое такс идём дальше по
сути вот именно эти два принципа open
клаус позволяет нам делать расширяемые
и потенциально разрабатываемый большой
командой
проекты dependency engine говорит о том
как нам это сделать потому что очевидно
не имея возможности работать с
абстрактным типом то здесь у нас ничего
не получится если у нас бы не было
возможностей работать абстрактным
месседжем знаю что есть реализации нам
бы пришлось писать сюда конкретной
реализации ну и все уже бы ничего не
работал без dependency энвер уже надо
без возможности вставить абстракции это
все 7 класс не работает то есть эти два
основных принципа которые как раз и
говорят о нашей скажем так большой цели
и о конкретном механизме как это делать
дальше близко в star citizen
этого значит такая архивная фотография
молодая барбара лисков еще один лауреат
премии тьюринга в нашем курсе
один из первых исследователей
теорий типов написала свое печки работу
которая в принципе было 1 можно сказать
про образом объектно-ориентированных
языков и прежде чем поговорить об этом
принципе я бы хотел немножко немножко
обратить внимание на один еще один миф
скажем так мне мифа какую-то претензию
или вопрос или предложение которое мне
задавали сразу три или четыре человека
относительно объектно-ориентированных
языков и в чате и потом мне отдельно
спрашивали потому что вот смотрите
объектно-ориентированные языки
объединяют себе внутри и данные и
алгоритмы и типа вот смотрите же плохо
наверное то есть вот такая вот ситуация
что с этим делать как с этим бороться
почему где живут отдельно давно есть
отдельный алгоритм я бы хотел на этом
остановиться потому что я не смог
наверное сразу сразу быстро развернуто
ответить
значит смотрите я приведу для начала
похожий пример
если кто-то пробовал писать код на юнити
это игровой движок то там значит выпьем
есть такая возможность есть такие
скрипты которые наследуются от
monobehaviour то есть у вас есть ваше
пространство в редакторе ну то есть это
полноценное 3d пространство у вас есть
там какие-то объекты например кубик вы
можете купить повесить скрипт который
вот как раз такой унаследованные там
атмана бихи вера в нем есть какая-то
логика поведение он там дергается при
старте приложения при каждом фрейме в
нем если обозначить поля через wan так
как здесь сериала и spilt то можно этот
скрипт появляется прямо в редакторе в
него в эти поля можно руками
перетаскивать какие-то объекты и
задавайте значения вот такая вот система
такой система для работы с движком здесь
есть
проблема проблема в том что за счет
такого подхода мы реально мешаем в кучу
логику и отображение то есть вот я
нагуглил первый попавшийся скрипт для
шахмат и вот у нас здесь
менеджер ну как бы все худшие практике
сразу вместе с менеджер не просто feel
the менеджер и в нем внутри вот есть
create фьюд который вот знаете нужно по
очереди вставить белые черные клетки и
он их создает не просто как-то
абстрактно сразу создает тут на на поле
на пространстве их отображения какая
затем получать то есть ну здесь если мы
напишем дальше там есть например там
яшка ладья все остальные фигуры то есть
они прямо так и сделаны эти их логика
написано в таких скриптах и здесь внутри
есть логика того как ходить там по
диагонали по буквой г и так дальше и тут
же сразу код который перемещает
непосредственный объект но уже на самом
поле здесь в кучу мешается логика и
отображение чем это плохо тем что
очевидно что логика шахмат не менялась
последние там 1000 нет то есть мы можем
вынести логику отдельно мы можем ее
написать один раз мы можем ее покрыть
тестами мы можем принципы штате очень
стабильной в то время как отображение
скорее всего будет меняться много раз то
есть наша вещь она теряет возможность
быть протестированной потому что я не
могу просто создать как вот мы приводили
пример я могу взять класс добавить туда
какие-то зависимости вызвать метод
и проверьте что отработал нормально если
здесь уже есть зависимость от объекта в
на сцене она пытается создать какие-то
вещи то я уже не могу просто день
какой-то метод мои возможности к
тестированию очень-очень сужаются
это такая вот проблема которая
присутствует если писать в таком режиме
песочницы
это я к чему к тому что сам когда я
сказал что данные логика обвиняется с
отображением это еще не проблема это
просто факт а вот проблема то что
очевидно что логика меняется по другим
законам чем отображение шахматы в
шахматах логика не меняется в принципе
если вы делаете какую-то свою нас толку
в компьютерном виде то вас логика будет
меняться по другим законам там будет
ребята работать над логикой юшка будет
работать отдельно и с этим реально
сложно работать потому
сложно тестировать 2 2 2 разных
направлений развития так дальше
является ли проблемой то что
объектно-ориентированные языки
объединяют в себе данные вместе с их с
логикой давайте так то что они меняют
пока что это только flygt давайте
посмотрим на пример реализации структуры
данных на чистом си как мы знаем в
чистом средние каких классов нет ничего
такого нет все есть только структуры в
которых есть структура то есть там есть
ссылки на какие-то объекты либо сами
объекты и есть какие-то методы которые
отдельно по сути существует простая
структура
список то есть это но до в которой и
ссылка на следующую ноту и какой-то
метод который позволяет посчитать
можно представить себе более сложный
пример например словарь то есть хэш
таблица в которой записью будет
структура который отображает какую-то
там представление одной ячейки например
и методы для работы с этими вещами какая
здесь получается ну неудобства проблема
если мы пишем структуру данных носить в
том что вот это вот структура да но да
мы ее отдаем клиенту да мы ее туда
отдаем плане того что мы написали вот
этот например у нас есть наш лист там си
и здесь есть наши методы
например там каунт я не ожидает что
будет ссылка на ноду при этом сама надо
гуляет у пользователя через записку
соответственно все эти данные
пользователю доступны в данной ситуации
это не проблема там есть просто да то
есть какой то ссылка на следующий если
мы представим более сложную структуру
данных например там вот тот же словарь
то как бы там могут быть куча других
данных соответственно если мы хотим
каким-то образом
уберечь часть данных внутри этой
структуры
от пользователя нам это сложно сделать
потому что нам же мы же не можем мы все
эти вещи хранятся в структур ки которую
мы отдаем пользователю которую мы потом
ожидаем быть переданы в конкретный метод
ип аккаунта до
того чтобы он мог корректно это все
обработать это как бы проблема потому
что мне все что пользователи нужно
точнее не все то что нужно нам нужно
пользователю пользователи возможно нужно
только какая-то одна часть этого вторая
проблема которая здесь возникает это то
что эти вещи начинают жить отдельной
жизнью то есть по сути где то в 3 у себя
вот эту структуру в коде мы как бы не до
конца понимаете а где же в какие-то
методы что с ней что с ней можно делать
куда можно вызывать они как бы же
существует отдельно друг от друга это не
очень удобно как эти проблемы решаются
ну например если вы поищите реализации
хэш-таблицу assigned a mature а это
искал то очень часто там
используя такой подход что по сути
структура становится статической то есть
мы создаем внутри статические переменные
для тех вещей которые мы не хотим
отдавать пользователю отдаем ему только
вот специальные структур ки которые с
которыми он может работать но при этом
поскольку у нас объектов возможности
создавать нет мы просто создаем эти
статические там какие-то структуры
внутренние и поэтому хэш-таблицы
становится но такой масштабный
глобальной 1 на весь проект ну потому
что мы же не можем по-другому сделать
это как бы частый вариант того как это
работает но не в таком виде когда есть
какая-то структура которая выдается
и которую нужно бросать назад
методы как бы было в идеале исправить
эту ситуацию нам бы очень хотелось чтобы
внутри структуры были вещи недоступны
для пользователя на доступные только для
самого алгоритма потому что ну
объективно сложно разорвать
структуру данных это скажем так
рассматривать ее отдельно от работы с
ней то есть если мы возьмем какой-то там
не знак раз на черное дерево да то что
то что такое структура данных это просто
дерево или все-таки это вместе с
алгоритмом когда мы добавляем туда
вершину как она перри балансируется то
есть это ведь комплексная вещь это
достаточно неразрывные вещи например
если мы придумали себе такой механизм по
которому вы смогли обозначать
обозначать некоторые поля такими что
недоступные для чтения
снаружи раз решило бы проблему и второй
механизм
каким-то образом связать вот эту
структуру с методами которые к ней
относятся чтобы когда кто-то надо будет
этот но ты у себя там в коде случайно
прилетевший чтобы он сразу понимал
какими методами можно пользоваться то
есть ну не знаю очевидно это или нет но
для того чтобы решить эти проблемы мы
как бы только что при перри придумали си
плюс плюс как только мы туда добавим
структуру модификаторы проявят public мы
тем самым создадим видимость этих полей
извне или внутри а способ сделать так
чтобы данные были связаны с методами он
очень простой если вы знаете или нет то
вот например когда мы делаем какой то
вот допустим наши но да .
каунт не какой-то там mind параметр то
это всего лишь нечто большее чем вызов
метода салют на процедурного каунт в
который неявным образом передается
ссылка на нашу структуру да и наш потом
второй параметр и в банк этой ссылке мы
внутри метода в любом объект
ориентированном языке внутри метода мы
можем обращаться через равносильно это
так просто компилируется в этом нет
никакой магии
соответственно мы специально связываем
их вместе для того чтобы решить две
проблемы того что мы хотим иметь
некоторые данные которые не доступны
пользователю и мы хотим чтобы эта штука
рассматривалось вместе
что дерево оно не она не является
деревом полноценным без методов работы с
деревом словарь является если можем
снова то это не просто какой-то список с
хэшами чем остальным эта штука важно
только когда мы имеем полноценный доступ
к методам работы с ней
это один аргумент против того что
связывание данных слоги кой оно не
является проблемой но скорее является
решением для других проблем и ну как бы
нельзя ли вы так рассматривать если вам
не нравится такой подход мы можем затем
немножко с другой стороны
что такое целые числа можете сказать ну
причалить и что такой вот так вот
идеально просто
да а какие операции
доступны над целыми числами ну скажем
так те которые вот
не приводят к появлению других чисел
сложение и вычитание в принципе это
обычно рассматривается вместе потому что
1 -2 тоже самое что 1 плюс минус 2
умножение безусловно работает деление
уже не работает том плане что если мы
умножим 2 целых числа результатом будет
целое если мы поделим целое на целое
результатом уже может быть не целых кто
знает как математически называется вот
эта вещь когда есть количество значений
и операции доступны внутри этих значений
нет именно вот эта вся структура кольцо
да он там прозвучал есть кольцо есть там
полукольцо из натуральные числа потому
что это часть отсюда есть более широкое
понятие поле когда мы ну то есть
принципе если мы рассмотрим достаточно
абстрактно то я могу придумать свой
собственный какой-то набор значений там
например обозначить их буквами да и
внести какие-то операции над ними я могу
придумать что можно делать там операцию
вот такую вот такую вот такую и как-то
их придумать как они будут работать это
может быть бестолковым таким упражнением
а может иметь серьезное применение когда
мы найдем этому какую-то практическую
штуку то есть какая-то криптография если
вы занимались там есть отдельные поля
который работаю дан то есть это вот
важная вещь которая с одной стороны
абстрактная но с другой стороны имеет
хорошая хорошая применимость то есть
говоря про целые числа мы в принципе
говорим про набор значений и операции
над ними доступно
интересно что ничего ли вам это не
напоминает когда мы создаем какой-то
объект какой-то тип внутри наших языков
да там и в принципе задаем возможное
количество значений да но видимся не
обязательно даже но здесь она бесконечна
и она просто понятно как создаются и мы
создаем операции доступные над нашим
типом просто что мы привыкли эти
операции обозначать не значками а
словами на например там и вызывать их
через скобочки 0 на принципиальном
уровне ведь это не отличается здесь
хорошим примером является язык скала
если кто-то пробовал там если мы возьмем
например и создадим в каком-то классе
метод который ну вот прямо плюс и
например внутри там то мы можем вызывать
оператор например вот наш объект плюс
если метод имеет только один параметр то
мы можем его
писать без точки и без без скобочек мы
можем описать его как оператор более
того сказал об позволяет создавать
методы ну например вот такой метод можно
создать то есть любыми значками
обозначать соответственно мы можем наш
плюс плюс да и таком случае вот эта
запись будет равносильно
вот такой записи то есть мы вызов метода
просто который называется плюсик это
более наглядно показывает про то что в
принципе мы тем же занимаемся мы создаем
типы да и создаем набор операций который
который доступен над этими типами в
скале кстати очень эстетически красиво
мне кажется используется например есть
такой метод который выглядит как три
вкуса и он бросает not implemented
exception то есть когда вы создаете там
в выдаёшь ки метод да он создается
пустым и внутри стоит три вопроса из его
вызвать в таком виде он бросит not
implement ну не знаю мне кажется что это
красиво
в таком виде типы даже самый самый
функциональный перри функциональный язык
имеет что то такое то есть вот
собственно и в sharp вот внизу даже
хаски а то есть мы постоянно работаем с
типами мы постоянно создаём значение и
операции над ними
да то есть здесь наверху это просто
называется типом они классом дано мы
определяем какой-то метод
хаскеле нам нужно хитрее сделать нам
нужно это типа как оля конструкторы и
количество опера и количество параметров
которые передается но мы постоянно
занимаемся этими вещами мы создаем
структуры которые состоят из значений и
и операции над ними соответственно их
сложно разрывать и говорить про то что
но мы же пользуемся вектором числом
энтом над которым определенные операции
и это для них из абсолютно естественно и
нормально что говоря про целые числа мы
понимаем что одними можно делать
операции и они вместе то же самое
касается и общего аргумента про то что
обработка логика и данные вместе это
какая-то проблема единственное что я
могу здесь сказать что естественно есть
ситуации когда мы поступаем по-другому
например вот если это обработка графики
да если кто то знает как работает
видеокарта если не знаете можете видео
посмотреть тоже есть от курса первом
семестре как там блогеры делает будет
сливать когда вот это вот все то есть
когда мы работаем с графикой то мы
организовываем вывод и изображение на
экран таким образом что у нас есть
определенная скажем так конвейер до
обработчиков которые принимают точки
порциями
да и обрабатывают их и выдают на на
экран за счет того что много точек много
этих обработчиков и они выдаются
шейдерами вы явно слышал это название
вас получается эффективность и там очень
логично что мы разделяем точки как вот
просто структура и обработчики которые
их принимают обрабатывают и пересылать
но это никак не отменяет того что мы его
повседневной жизни продолжаем
пользоваться векторами которые можно
рассматривать как структуру данных вот
такую да то есть можно рассматривать что
вектор это не определенный набор
значений да и к алгоритмы работы с ним
да то есть как бы нормализация там
сложение мы можем рассматривать вектор
мать
магически что это типа канат которого
определены понятия это всего лишь два
разных подхода но оба них прекрасно
основываются о том что данные связаны с
операциями
почему я это все рассказываю мина в этом
разделе потому что как раз вот госпожа
лисков она занималась изучением
абстрактных типов
она занималась как раз вот вот этими
вопросами того как можно перенести ну то
есть математически
как мы можем использовать типы как как
нужно их конструировать как они нам
могут помочь при написании программ в то
время когда еще не было
объектно-ориентированных языков но
естественно математическая основа была и
она написала свою печень и работу
основанную как раз на изучение того как
вот нам конструировать эти типы которые
наследуются друг от друга ну а мы все
это хорошо знаем что есть например
натуральные целые числа любой naturally
является целым у то есть это вроде бы
как понятно интуитивно понять ее и
главным достоянием скажем ее работы
которым мы продолжаем пользоваться
является собственные принципы постановки
лизка о чем он говорит он говорит о том
что если у нас есть два типа но как
минимум несколько типов один из которых
является по типам 2 то везде где
используется супер тип да то есть
родительский тип везде всегда должен
иметь возможность использоваться тип
наследника в жизни это кажется очень
простым то есть если мы проектируем
детское кресло например то очевидно что
если мы посадим туда мальчика но должно
работать потому что дети бывают мальчики
и девочки если мы сделали кресло для
всех детей
то для девочек оно тоже должно работать
для мальчиков должно работать если мы
сделали там какой-то кафе для
спортсменов мы должны туда пускать и
шахматистов и велосипедистов это
достаточно очевидно то есть это
интуитивно понятно что если что-то
работает с большим типом то любой пути
должен туда подходить проблема
начинается в том что когда мы пишем
программы
то мы работаем не с теми абстракциями
которые существуют в мире без нас то
есть там типа дети которые делятся там
на мальчиков и девочек
мы еще и сами типы
сдаю то есть мы сами создаем эти типы и
мы можем их связать так что они не будут
сохранять эту пропорцию
мы можем создать такие кривые типы для
которых вот эта штука не будет работать
и это приведет к плохим последствиям
пример хрестоматийный у нас есть класс
замечательный класс rectangle все писали
класс rectangle do the mood шеи по
наследуется у него есть что у него есть
вы
и у него есть хайд замечательно да то
есть это вот у нас есть такая штука все
все работает и у него есть например
метод сетует eset хайд напиши пусть
будем считать что это на джаве написано
если был пожар были бы property или еще
что-то другое сумму очень прост и вам
задание сделайте класс квадрат да и вы
такой rectangle
унаследуем почему потому что любой
квадрат является прямоугольником логично
же да поэтому у нас такая будет красиво
ерохин исследование давайте для красоты
даже шейка туда допишем как во всех этих
и вроде как все хорошо вот вы смотрите
вот тут есть методы считается эци тхай
но типа она как бы в квадрате это все
одинаково да как бы высыхает одинаковы
поэтому мы возьмем переопределим и
сделаем так что и высыхает в квадрате
будут работать одинаково и будут
выставлять обозначения ну вроде как
нормально когда мы ставим квадрату
ширину у него же лишь высота меняется и
наоборот ну вот так мы сделали такую
ношу иерархию типов а какая проблема
проблема в том что если кто-то где-то в
нашей программе какой-то другой
пользователь программист работает со
списком rectangle of да например
какой-то алгоритм пишет интегрировании
там прямоугольничка неважно работает со
списком и он значит делает там такую
банальную операцию он берет и для
каждого там rectangle а который ему там
приехал fix
например уменьшает ему ширину в два раза
например ему это нужно для каких то
целей там что то сделать если вы
уменьшаете в ширину прямоугольника в два
раза то сколько раз меняется его площадь
два раза то есть как бы пользователь
ожидает что после такой операции у
rectangle a square станет два раза
меньше но вдруг по какой-то причине
поскольку каждый квадрат является
прямоугольником и он может быть в этом
списке
ну прекрасно затесаться там где-то он
появился то в этом списке среди
прямоугольников за и записывается ваш
квадрат которому при выставлении высоты
в два раза ширины в два раза по нашему
прекрасному алгоритму меняется еще и
высота в два раза это же квадрат
правильно и площадь меняется в сколько
раз 4 и человек смотрит на свой список
из на прямоугольника вы у него что то не
сходится вообще да о чём это говорит это
говорит о том что очень важное понятие
которое часто как бы формулируется в том
что наши абстракции которые мы создаём
внутри программы
они никаким образом автоматически не
наследует никакие абстракции
присутствующие в жизни то есть то что вы
создали классный контент и сквер еще они
вообще ни разу не гарантирована что вот
вы уже знаете что чего нужно следовать
потому что данные структуры да они имеют
смысл только в применении понимая того
как вы будете их применять и вот вот это
применение когда мы уменьшаем в ширину
квадрата там ширину прямоугольника она
сразу говорит о том что мы не можем
применять эти квадраты и наша вот эта
иерархия на не работает нам нужно это
переделать нам нужно по-другому к этому
подойти возможно их не стоит создавать
такую rar возможно то здесь вот если бы
они были
и мутабельные то например этой проблемы
бы не было могла возникнуть другая
проблема которая бы там тоже
как это проявилось то есть нам здесь мы
сами создаем типы
если в примере с детским креслом для
девочек все очевидно потому что муж для
всех сделай то здесь мы можем создать
такое кресло которое как бы работает
чем-то одним но вот там не работает чем
это плохо это плохо тем что
простом виде когда вот человек увидит
что зараза приезжает это квадраты и не
работает он начнет пытаться как то здесь
костыли пись знает что есть супер тип
rectangle
но один из подтипов ведёт себя не так
как ему положено
соответственно чтобы не сломать наш
алгоритм мы будем обрабатывать отдельную
логично если у вас нет доступа сюда вы
пытаетесь найти для этого какое-то
workaround
соответственно вот например наш снова
пример с с интером по тисе пи
у нас есть наши в райтер который
прекрасно работает но вот у нас такая
штука что raider может быть например
ht типичным и для того чтобы вести
типичный работал ему нужно урал еще
передать соответственно все в райтеры
как люди да люди как люди и пишут
нормально а вот что типичному нужно еще
уровень задач и вот тоже самое как всех
все прямоугольники нормальные а квадрат
и окисной такие и приходится на это
проверять да и как-то обрабатывать
отдельно и в чем получается загвоздка в
том что как только вы проверили вот этот
тип один раз здесь к чему мы пришли к
тому что мы сразу же сломали вот эту
штуку мы как только мы ломаем там и всё
ломаем и
его тоже ломается фан-клуб в том плане
что как только мы добавили ссылку вот
здесь вот до
теперь этот модуль зависит от конкретной
реализации раньше у нас там не было
никаких ссылок мы работали с интерфейсом
а теперь есть да вот этот наш красивый
рисуночек
open клаус он теперь тоже не работают
потому что как бы вот наша левая часть
которая работала с абстракцией она
работает с абстракцией но иногда
обрабатывает еще пару исключений и как
бы вот это вот все плохо когда вы
захотите переписать свой архетипе байт
вайпер вам придется влезть в high level
полисе вычищать эти iv и нута и сломать
и все остальное вот об этом говорит
лизка в запустить у шиндо тоже наши типы
должны всегда работать так что если мы
используем там где мы ожидаем родителя
используем любого чая да он должен
работать нормально
важным следствием отсюда является то что
нет никакой автоматично стена следование
то что является схожим в жизни не факт
что в нашей системе должно друг от друга
наследоваться мы должны подумать об этом
исходя из механизма в использовании так
мы уже немножко затягиваем поэтому я
чуть чуть ускорюсь потому но нам
остались несложной вещи мы их быстренько
проскочим в том плане что если это были
такие вот основополагающие вещи то
остались два принципа которая важна и но
не на столько не настолько длинные
сложны для понимания
буква s сингл responsibility принципу с
него все начинают и как бы должно быть
понятно что класс должен иметь только
одну задачу до сингла responsibility
должен заниматься чем-то одним
чем это помогает тем что вас нет такой
возможности чтобы кто-то вы делаете с
кем-то
вам приходится сдаем ковыряться в одном
классе какие-то другие проблемы которые
возникают но в чем минус формулировки
сингл responsibility в том что класс
должен иметь одну задачу потому что одна
задача
слишком размытое понятие то есть
например вот у меня есть класс message
из нашего skype громада и у него есть
методы нарисоваться на канвасе условном
у него есть метод сохранится в историю в
него есть метод подсветится это все как
бы мы можем это назвать одной задачи то
есть работа с конкретным месседжем
например и в таком виде вы как бы знаете
что клад нужно иметь эту задачу но вы не
знаете как это применять потому что ну
всегда можно посмотреть на классы понять
что он занимается чем-то одним особенно
вот я когда
ругался на класс менеджер особенно когда
у вас класс называется не просто
game ну там вот не game 1 да вот
например там field как здесь было до а
какой-то менеджер или контроллер что
угодно такую почему потому что когда вы
говорите например ну например figure да
например вот шахматы какие то вы
понимаете что такое фигура у вас есть
какое-то представление но там начнет это
у нее изгиб у нее может позиция быть
цвет ну все понятно как только мы
говорим figure менеджер то как бы туда
уже что хочешь делать правильно то есть
и по он может их хранить рисовать
сохранять отправлять обрабатывает делать
что угодно то есть мы за счет такого не
очень удачного названием и сразу
приводим к тому что задача типа
занимается одной задачей она становится
всегда правильной потому что чем
занимается ваш game менеджер занимается
игрой до managed игру как managed игру
во всех ну вот в любых понятия какие мы
только можем понять
для того чтобы избавиться от этой
проблемы принцип хороший принцип который
позволяет нам разбивает программу на
более мелкие части которые потом
легче работать легче заменять все
остальное нужно просто по-другому
сформулировать более понятной форме эта
форма звучит так класс должен иметь одну
причину изменяться становится намного
проще то есть в нашей ситуации вот этот
класс который мы сочи
когда он будет меняться когда мы
поменяем механизм отрисовки на канвасе
ну например там нужно будет массаж
рисовать не слева направо справа налево
другим цветом заменять на то есть
поменяются тогда когда мы поменяем
механизм сохранение в историю там
логирование там будем писать в txt файл
в базу данных или еще что-то когда мы
поменяем принцип подсветки будет ли это
вовлечения в размере ли жирненькие шрифт
то есть у нас есть при потенциальные
задачи при которых этот класс может
меняться то есть при возникновении их
троих сразу три человека условно могут
менять этот класс одновременно особенно
если они еще будут зависимость на
какие-то внутренние приватные поля
все тоже будет не очень хорошо шанс того
что все сломается тоже большой это
увеличивает есть такое понятие как
сцепленность по-английски пишется как
vision vision он говорит о том насколько
класс сцеплен своей задачи класс
занимается чем-то одним
да то он это высокая высокая
сцепленность
а если он занимается многими вещами то
она получается такая маленькая рыхлая
как вот здесь да то есть мы можем этот
класс он не до конца понятно чем он
занимается потому что он и подсвечиваете
сохраняется рисует если мы будем
двигаться по такому принципу то мы сразу
видим где здесь есть точки которые
следуют которые требуют выделения то
есть какие классы могут быть выделены
для того чтобы иметь возможность
меняться да то есть только по одной
причине это собственно есть наша тресов
щик это сохранение это подсветка
можно привести другие примеры это очень
хороший механизм когда вы занимаетесь
каким-то рефакторинга какого-то legacy
кода когда там есть две тысячи строк
2000 строк это не всегда плохо 2000
строк иметь какие-то библиотечные
структуры данных которые которые не
изменяемы то есть мы написали словарь
там 0 в microsoft и написали или ворог
ли ну и у него есть на матушкой 35
методов допустим и вот он
протестированный он таким монолитом
существует для него не проблема что он
внутри оптимизирована имеет нам размер
3000 строк типа это абсолютно og он для
своей скорости для всего остального
жертвуют такими вещами но для классов
которым постоянно меняются для классов
нашей логике когда они разрастаются до
большого размера то скорее всего у них
сцепленность очень маленькая скорее
всего они занимаются много чем скорее
всего у вас большой шанс что система
станет хрупкой и жесткой потому что
когда вы начнете менять один метод вы
поймете что он зависит от других и нужно
переписать все о хрупкой почему потому
что власть за сюда в highlight можно
поменять что-то не случайно сломать
отрисовку запросто там будет какая-то
переменная общие какие-то состояния
будет общего там типа меняться что здесь
вот она будет хайлайты було здесь не
хайлайта было там если рисовать то она
по-другому рисуются и мы тут переменной
поменяли атамана используется но и все
все сломалось
вот вот он тоже самое хрупкость при
таком разделении у нас намного больше
возможности сделать это правильно
картинка про сингл responsibility to
fork spoon из пурк ну кстати есть такие
штуки до туристические они удобные но в
чем проблема
чем отличается этот пример от
туристических удобный штук тем что вот
такой вот пурк
если он создан один раз то фиг с ним дам
им пользуемся он стабилен но мы же знаем
что наша ситуация это когда система
меняется постоянно меняются люди которые
над ней работают меняются требования
ответственно наш этот пурк в чем его
проблема в том что вот у нас постоянно
будет возникает ситуация когда например
нам нужно сделать
ручку ложки в 3 раза длиннее но ручку
вилки оставить такой же ну и как бы в
этой ситуации это задача становится не
мешаем и и мы скажем наш архитектура
такого не позволяю хотя и ну как бы это
очень
вроде бы как нормальное требование там
размер увеличивайте сестры поэтому
сингла responsibility это один повод
меняться последняя вещь быстро
проскакиваем это разделение
интерфейса интерфейс сегрегация принципу
здесь я приведу пример из game девам не
за точно нравится мне кажется он
наглядный в чем суть мы уже определились
с вами что нужно выделять интерфейс
экстракции это хорошо все замечательно
осталось теперь понять как их выделять
на то есть вот как взять класс который
мы написали как оттуда
выделить абстракцию мы уже знаем что эта
абстракция не должна зависеть от деталей
что еще например у нас есть класс и нами
враг у него есть один них здоровья он
мои тебя сохранять и например он там у
него есть какая-то скорость
если мы просто вот так вот бахнем
алленами и вынесем все методы наружу что
что является таким мисс юзом что ли
такого принципа когда мы открываем
какую-то программу увидим что там есть
класс и есть для каждого классный
интерфейс который вот прям один в один
у нас есть там room ai грунтом мэн мэн и
все вот все такое один в один
является ли это хороший выделением
интерфейсов или нет ну не совсем потому
что вот в таком наборе очевидно что
такое интерфейс никому не нужен да то
есть вряд ли есть какая-то сущность
который нужен интерфейс которому нужно
есть одновременно и а иди и хелс ессеев
и скорость скорее всего обработчики
будут разные для этих ситуаций и когда
мы захотим поменять наш иными то как бы
у нас мало возможности реализовать этот
интерфейс по другому да потому что мы по
сути должны бы нарисовать эти методы
которые здесь именно в таком виде
сделаны и у по сути скорее все получится
то же самое потому что будут те же
зависимости те же методы ну и
пространство для переписывания
маневрирования добавление 2 реализации
очень маленькая нашим ситуация это вот
такой вид это интерфейс и клиенты
которые работают с этим большим
интерфейс а что можно сделать
собственно интерфейс сегре гейш
разделение интерфейсов правило очень
простую
в этом примере мы выделяем интерфейс от
класса то есть у нас есть
потребителей для интерфейса да есть вот
скажем нет уже производителя источник
класс
мы взяли класс и создали интерфейс и
потому что он предоставляет а надо
сделать наоборот нужно взять наших
клиентов и посмотреть что каждому из них
нужно
и вылить интерфейсы по их потребности
соответственно каждый клиент будет иметь
маленький интерфейс на тот с которым он
хорошо работает нашем случае это что
кому-то нужны
нужны сохранения ему нужен интерфейсами
себя лайза был и мунин не пони ему не
важно что там сохраняется враг дерево
там или игрок кому-то нужны все объекты
которые умеют двигаться например там в
игре это может быть хоть спел заморозить
всех ему нужно просто заморозить всех и
для этого ему нужны все объекты которые
двигаются кому-то нужны все живые
объекты тоже какое-то заклинание примеры
с кем дело всегда приводить легко потому
что огромное пространство для
придумывания ну или я в этой связи
слишком глубоко понять
кому-то нужны просто вещи которые можно
ну там скажем перечислять сложить мапу
там хищники да то есть мы видим что
каждая из них это отдельные применение
которое очень специфическая и наш враг
наш и нами на самом деле он просто
является реализация для всего этого мы
разделили наш интерфейс по потребителям
и как бы по сути и нами наш не поменялся
но он реализовывает теперь просто набор
этих маленьких интерфейсов теперь когда
мы захотим поменять ее нами нам это
будет сделать намного легче мы теперь
сможем на самом деле вот здесь вот не
очень красиво да здесь вот есть и
здоровье и сохранение мы хотим вынести
сохранение отдельно мы можем это сделать
потому что нам не нас нет необходимости
таскаться с вот этим интерфейсом и
нами которые теперь за жестко забит на
сайт да мы просто должны как то
придумать другую структуру какой-то
другой сериал ой забыл сделать вынести
его и он с этим будет понятно и хорошо
работать нашей картинки это показано в
виде универсальной зарядки в которой
есть и такая разъемы такое которая на
самом деле вообще бестолковое да потому
что никто никогда не будет пользоваться
этим одновременно скорее всего может
быть это не такой удачный пример но по
крайне мере он наглядный в том плане что
когда мы пользуемся какими-то
конкретными вещами нам легче понять что
нужно выделять чем когда мы просто
создаем от от того что имеем просто
выделяем все методы property
это как бы не решение наших проблем
более того именно в таком виде это
хорошо накладывается на то что мы
говорили про dependency безначально да
то есть у нас есть наши сервисы
например тот который работает с ее вами
и здесь же рядом с ним интерфейса
сериала и забыл и остальные вещи которые
его реализуют а эта вещь она прекрасна
она даже переносим а в другой проект
потому что у нас есть например обработка
там сохранение на диск в облака все
остальное но все что нужно это типа
дайте мне список сериала из облав
которые умеют отдавать байты а я уже сам
там что-то порешаю да и мы потом эту
штуку можем взять и прекрасно перенести
в отличие от того если здесь например мы
сюда запихивали список и нами entity
всего остального
и тогда бы это выковыривал ася туда
гораздо тяжелее нужно было еще от
отпиливать лишние части да это то самое
mobility которая нам мешает так я хотел
еще раз сказать про задание для
студентов на их наверное просто выложу
вечером по сути задание я скажу что это
будет вот вот этих вот это чтобы знание
это это скорее как направление туда что
можно почитать и посмотреть я
обязательно выложу все ссылки на которые
ссылался
их нужно применять потому что алан кей
которого я нашел на корридой который
пишет нам замечательные ответы сказал
что практическое занятие программным
разработкой по это то же самое как
теоретическая
консерватория то есть вы пришли
посмотрели как преподаватель играет на
гитаре и такие ну все понятно научился
очевидно же очевидно что вам нужно
играть нужно пробовать поэтому задание
будет как раз на здании такой системы
которая расширяется я выложу задание
прямо сейчас приду сегодня и выложу для
тех кто как бы не студент естественно
что для вас это не обязательно и все
остальное просто попробуйте на это
посмотреть хотя бы подумать как бы вы
это делали потому что все эти вещи они
ну важен и когда вы пробуете их
применить когда вы приходите на работу
посмотрите свежим когда на свой код и
понимаете ну вот можно найти что-то
поменять что здесь нарушает где здесь
какой принцип нарушается и что можно
сделать чтобы сделать этот код лучше
это вот спойлер задание сейчас будет
маленький а почему тут нарисован steam и
drive вы уже узнаете глядя на git hop до
всем спасибо